
[Bijhorende powerpoint](OOSD1_SlidesH5.ppsx)
#  Doelstellingen


- om **alle onderdelen** van een DCD correct te benoemen  
- om **de betekenis** van een DCD te begrijpen  
- om **een DCD op te bouwen** op iteratieve wijze met behulp van 3 GRASP-patronen: *controller*, *creator* en *expert*  
- om **een systeemoperatie** te definiëren met de correcte verantwoordelijkheid (*doing*/*knowing*)  
- om de systeemoperaties op te splitsen in **deelverantwoordelijkheden** die op het DCD kunnen geplaatst worden  
- om **een DCD om te zetten naar Java-code**  

# Inleiding

- Software ontwikkelen verloopt via een iteratief proces. 
- In elke iteratie worden een aantal fases doorlopen die voorgesteld worden door de figuur hieronder.

![](20250105225343.png)


## Requirement Analysis

- We starten bij de *“Requirement Analysis”*. 
- **Goed begrijpen wat de klant precies wil en goede afspraken maken met die klant zijn hier super belangrijk**. 
- In het opleidingsonderdeel **Software Analysis** leer je hier heel wat over.

## Design, Implementation en Testing

- De volgende drie fases *Design*, *Implementation* en *Testing* komen alle drie aan bod in het opleidingsonderdeel **Object Oriented Software Development I**.  

- In de **vorige hoofdstukken hebben we ons vooral gefocust op het onderdeel** *Implementation*. 
	- We hebben geleerd **eenvoudige functionaliteit te vertalen naar Java-instructies**. 
 
- In dit hoofdstuk zullen we ons nu concentreren op het *Design*.
	- Dit is de **fase tussen de analyse en de implementatie**. 
	
- Uit de analysefase heb je geleerd wat je klant wil en dat heb je vertaald in een aantal producten: 
		- **UCD** (= use case diagram)
		- use cases
		- domeinmodel
		- SSD en eventueel bijhorende OC’s. 
	- Op basis van deze diagrammen zullen we verder gaan om een ontwerp te maken. 
	- Het is belangrijk dat dit ontwerp goed aansluit op de analysefase.

* In die **ontwerpfase wordt normaal gezien eerst beslist welke programmeertaal/programmeertalen gebruikt worden**.
	* Maar in dit opleidingsonderdeel moet deze keuze niet gemaakt worden
		* er zal steeds **Java** gebruikt worden. 

* Wij zullen een **gedetailleerd ontwerpklassendiagram uitwerken** 
	* dit klassendiagram is dan het startpunt van de volgende fase: 
		* dat klassendiagram moet dan **geïmplementeerd** worden.

![](20250105230514.png)
# Ontwerpklassendiagram

### Inleiding

Een **ontwerpklassendiagram** (Design Class Diagram, DCD) is een essentieel onderdeel van het ontwerpproces in softwareontwikkeling. Het biedt een gedetailleerde weergave van de klassen binnen een systeem, inclusief hun attributen, methoden en de relaties tussen deze klassen. Dit diagram speelt een cruciale rol in het vertalen van de analysefase naar een daadwerkelijke implementatie in Java.

### Verschil tussen Analyse- en Ontwerpniveau

Bij het overzetten van een klassendiagram van analyseniveau naar ontwerpniveau worden er extra details toegevoegd. Terwijl een domeinmodel op analyseniveau zich richt op de conceptuele structuur zonder specifieke datatypes, bevat een DCD op ontwerpniveau gedetailleerde informatie zoals datatypes, constructors, methodesignaturen en meer specifieke associaties.

### Context

Om de verschillende onderdelen van een DCD te begrijpen, is het belangrijk om te werken binnen een specifieke context. Deze context biedt een kader waarin de klassen en hun onderlinge relaties worden gemodelleerd, waardoor een helder beeld ontstaat van het te ontwikkelen systeem.

### DCD (Design Class Diagram)

#### Soorten UML-diagrammen

**UML (Unified Modeling Language)** onderscheidt twee hoofdtypen diagrammen:

1. **Structuurdiagrammen**: Modelleren de statische structuur van een systeem.
    - **Statische Structuurdiagrammen**: Bevatten onderdelen van het systeem op verschillende abstractieniveaus, zoals het domeinmodel en het DCD.
2. **Gedragsdiagrammen**: Modelleren het gedrag van een systeem.
    - **Dynamische Structuurdiagrammen**: Beschrijven de gedragingen en veranderingen binnen het systeem over tijd, zoals System Sequence Diagrams (SSD) en Activity Diagrams.

#### Kenmerken van een DCD

- **Structuurmodellering**: Een DCD toont de statische structuur van het systeem door de klassen en hun onderlinge relaties te beschrijven.
- **Klassen en Relaties**: Meerdere klassen worden weergegeven met hun attributen en methoden, evenals de associaties tussen deze klassen.
- **Implementatiebasis**: Het DCD dient als basis voor de implementatiefase, waarin de gevisualiseerde klassen worden omgezet naar daadwerkelijke Java-code.

### Klassen in een DCD

#### Definitie van Klassen

Een klasse in een DCD vertegenwoordigt een blauwdruk voor objecten binnen het systeem. Elke klasse bevat:

- **Attributen**: Eigenschappen die de staat van een object beschrijven.
- **Constructors**: Methoden voor het initialiseren van objecten.
- **Methoden**: Gedragsfuncties die de functionaliteit van de klasse definiëren.

#### Associaties tussen Klassen

**Associaties** geven de relaties tussen klassen aan en beschrijven hoe objecten van verschillende klassen met elkaar verbonden zijn. Een associatie kan de richting en multipliciteit van de relatie specificeren, evenals andere eigenschappen zoals visibiliteit en navigeerbaarheid.

### Preciseren van een Associatie

Om een associatie volledig te begrijpen, moeten de volgende aspecten worden gespecificeerd:

1. **Rollen**: De twee uiteinden van de associatie, die aangeven hoe de betrokken klassen elkaar benaderen.
    
2. **Multipliciteit**: Geeft aan hoeveel instanties van een klasse deelnemen aan de relatie.
    
    - **Symbooloverzicht**:
        
| Symbool  | Omschrijving                                    |
|----------|------------------------------------------------|
| `*`      | Meerdere                                       |
| `1`      | Exact één                                      |
| `0..1`   | Maximaal één, maar mogelijk geen               |
| `1..*`   | Meerdere, maar minimaal één                    |
| `n`      | Exact n (waarbij n een positief geheel getal is) |
| `n..m`   | Minimaal n en maximaal m                        |
| `0..*`   | Komt overeen met `*`                           |

        
3. **Naamgeving**: De namen die worden gebruikt om de gerelateerde objecten aan te spreken binnen de associatie.
    
4. **Visibiliteit**: Bepaalt of de relatie publiekelijk toegankelijk is (`public`) of beperkt tot binnen de klasse (`private`). In dit geval is de visibiliteit altijd `private`.
    
5. **Navigeerbaarheid**: Geeft aan welke kant van de associatie navigeerbaar is, d.w.z., vanuit welke klasse de relatie kan worden gevolgd.
    

### Navigeerbaarheid van Associaties

- **Enkelzijdige associatie**: Alleen één van de klassen kan de associatie navigeren, aangegeven door een pijltje.
- **Dubbelzijdige associatie**: Beide klassen kunnen de associatie navigeren, zonder pijltjes maar met gespecificeerde rollen aan beide zijden.

### Van DCD naar Java-code

#### Equivalente Klassen

Elke klasse in een DCD heeft een overeenkomstige klasse in Java. De volgende aspecten moeten exact overeenkomen:

- **Naam van de Klasse**: De naam in het DCD moet hetzelfde zijn als in de Java-klasse.
- **Attributen**: De attributen moeten identiek zijn in naam en datatype.
- **Constructors en Methodesignaturen**: De signatuur van constructors en methoden moet overeenkomen, inclusief parameters en returntypes.
- **Implementatie**: In Java moeten constructors en methoden een daadwerkelijke implementatie bevatten.

#### Attributen en Associaties in Java

- **UML-associaties** worden in Java gemodelleerd als attributen.
    - **Niet-navigeerbare rol**: Geen attribuut wordt toegevoegd.
    - **Navigeerbare rol**: Een attribuut wordt toegevoegd met de naam, visibiliteit en type zoals gespecificeerd in de associatie.
    - **Multipliciteit > 1**: Het attribuuttype wordt een verzameling (bijvoorbeeld `List<>`).

#### Attribuutvoorstelling

Voor attributen van primitieve en voorgedefinieerde types wordt de **attribuutvoorstelling** gebruikt in het DCD. Voor relaties tussen zelfgedefinieerde types (onze klassen) worden **associaties** gebruikt. Het is belangrijk om attributen van zelfgedefinieerde types niet als attributen van primitieve types te modelleren, omdat dit het visuele verband en de multipliciteit verstoort.

### Aandachtspunten bij de Implementatie

- **Encapsulatie**: Attributen zijn altijd `private` en toegankelijk via publieke methoden. Dit zorgt ervoor dat de interne staat van objecten alleen via goed gedefinieerde interfaces kan worden gemanipuleerd.
- **Consistentie**: Zorg ervoor dat alle aspecten van het DCD correct worden overgenomen in de Java-implementatie, inclusief naamgeving, types en visibiliteit.
- **Verlies van Semantiek**: Bij het direct modelleren van relaties als attributen kunnen belangrijke semantische informatie verloren gaan, zoals multipliciteit en navigatie. Daarom wordt aangeraden om associaties expliciet te modelleren in plaats van alleen attributen te gebruiken.

## Conclusie

In dit gedeelte hebben we de basisprincipes van het ontwerpklassendiagram (DCD) besproken binnen het iteratieve softwareontwikkelingsproces. We hebben de verschillen tussen analyse- en ontwerpniveau benadrukt, de structuur en kenmerken van een DCD uitgelegd, en de manier waarop associaties worden gepreciseerd en gemodelleerd. Daarnaast hebben we de overgang van een DCD naar Java-code behandeld, met aandacht voor belangrijke implementatieaspecten zoals encapsulatie en het behoud van semantische informatie.

In de volgende secties zullen we verder ingaan op de specifieke onderdelen van een DCD, de betekenis ervan, en hoe deze iteratief kunnen worden opgebouwd met behulp van GRASP-patronen zoals controller, creator en expert. Daarnaast zullen we bespreken hoe systeemoperaties correct gedefinieerd en opgesplitst kunnen worden in deelverantwoordelijkheden binnen het DCD, en uiteindelijk hoe het DCD efficiënt kan worden omgezet naar Java-code.
# Het ontwerp: klassendiagram opbouwen


Uitstekend, laten we verder gaan met het verwerken van het volgende deel van het hoofdstuk "Ontwikkel een applicatie". We zullen de inhoud structureren en verduidelijken, waarbij we ervoor zorgen dat alle doelstellingen worden behandeld zonder het gebruik van voorbeelden.

## Het ontwerp: klassendiagram opbouwen

Objectgeoriënteerd ontwerpen is het proces van het bouwen van een **systeem van objecten** die met elkaar interageren, met als doel het oplossen van een softwareprobleem. Dit proces is essentieel voor het creëren van een robuuste en onderhoudbare applicatie.

### Fasen van Ontwerp

#### Einde van de Analysefase

Aan het einde van de analysefase hebben we de volgende artefacten ontwikkeld:

- **Use Cases**: Beschrijvingen van interacties tussen gebruikers en het systeem.
- **Activity Diagrams (AD)**: Diagrammen die de stroom van activiteiten binnen het systeem weergeven.
- **Domeinmodel**: Een model dat de kernconcepten en relaties binnen het toepassingsgebied van de software definieert.
- **Systeemsequentiediagrammen (SSD)**: Diagrammen die de interacties en volgorde van gebeurtenissen binnen het systeem beschrijven.
- **Operation Contracts (OC’s)** (optioneel): Specificaties die de voorwaarden en resultaten van systeemoperaties definiëren.

#### Ontwerpfase

Het doel van de ontwerpfase is het maken van **een klassendiagram** dat objecten, hun structuur en interacties weergeeft. Dit diagram dient als blauwdruk voor de implementatie en zorgt ervoor dat het ontwerp aansluit op de bevindingen uit de analysefase.

### Responsibility Driven Design (RDD)

#### Aanpak

**Responsibility Driven Design (RDD)** wordt toegepast om tot een klassendiagram te komen. Hierbij worden objecten geïdentificeerd met specifieke **verantwoordelijkheden** die **samenwerken** om de gewenste functionaliteit te realiseren. Elk object speelt een specifieke **rol** met bepaalde verantwoordelijkheden, wat bijdraagt aan een duidelijke en onderhoudbare architectuur.

#### Verantwoordelijkheden

Verantwoordelijkheden binnen RDD worden onderverdeeld in twee categorieën:

1. **KNOWING-verantwoordelijkheden**
    
    - **Definitie**: Verantwoordelijkheden die betrekking hebben op het kennen en teruggeven van informatie.
    - **Eigenschappen**:
        - Het object weet van zijn eigen toestand via privé-geëncapsuleerde attributen.
        - Het object kent gerelateerde objecten binnen het systeem.
        - Het object kan informatie berekenen of afleiden op basis van zijn gegevens.
2. **DOING-verantwoordelijkheden**
    
    - **Definitie**: Verantwoordelijkheden die betrekking hebben op het uitvoeren van acties.
    - **Eigenschappen**:
        - Het object kan zelf acties uitvoeren.
        - Het object kan acties initiëren in andere objecten.
        - Het object kan activiteiten in andere objecten coördineren.

### GRASP (General Responsibility Assignment Software Patterns)

#### Gebruik van GRASP

**GRASP** biedt richtlijnen voor het toekennen van verantwoordelijkheden aan objecten binnen een systeem. Deze patronen helpen bij het creëren van een gebalanceerde en efficiënte objectstructuur, wat bijdraagt aan de kwaliteit en onderhoudbaarheid van de software.

#### GRASP Patronen

Er zijn **drie hoofdpatronen** binnen GRASP die centraal staan in dit ontwerpproces:

1. **Controller**
    
    - Verantwoordelijk voor het afhandelen van systeemgebeurtenissen en het coördineren van acties binnen het systeem.
2. **Expert**
    
    - Verantwoordelijk voor het kennen en beheren van relevante informatie binnen het systeem.
3. **Creator**
    
    - Verantwoordelijk voor het aanmaken van nieuwe objecten binnen het systeem.

### Stappenplan: RDD en GRASP in Actie

Om een effectief klassendiagram op te bouwen, volgen we een systematische aanpak waarbij RDD en GRASP worden geïntegreerd:

1. **DOING / KNOWING**
    
    - Bepaal de verantwoordelijkheden van elke systeemoperatie zoals beschreven in de SSD. Dit helpt bij het identificeren welke objecten welke taken moeten uitvoeren.
2. **Bepaal Methode**
    
    - Definieer een methode voor elke verantwoordelijkheid. Methoden die DOING-verantwoordelijkheden hebben, moeten altijd een returntype `void` hebben, omdat ze acties uitvoeren zonder een direct resultaat terug te geven.
3. **Opsplitsen in Deelverantwoordelijkheden**
    
    - Splits de verantwoordelijkheden op en wijs ze toe aan geschikte klassen binnen het DCD. Dit zorgt voor een duidelijke scheiding van taken en bevordert de cohesie binnen de klassen.

### Einddoel

Het einddoel van dit ontwerpproces is de **iteratieve opbouw** van het ontwerpklassendiagram (DCD). Dit gebeurt door elke use case en elk SSD te doorlopen, waarbij het DCD voortdurend wordt verfijnd en uitgebreid. Deze iteratieve aanpak zorgt ervoor dat het ontwerp steeds verder wordt verfijnd en dat het systeem geleidelijk aan robuuster en beter gestructureerd wordt.

## Conclusie

In dit gedeelte hebben we het proces van het opbouwen van een ontwerpklassendiagram (DCD) binnen het objectgeoriënteerde ontwerpproces besproken. We hebben de fasen van het ontwerp geïdentificeerd, de principes van Responsibility Driven Design (RDD) uitgelegd, en de toepassing van GRASP-patronen behandeld. Daarnaast hebben we een stappenplan gepresenteerd voor het toekennen van verantwoordelijkheden en het iteratief ontwikkelen van het DCD. Deze systematische en gestructureerde aanpak vormt de basis voor het ontwikkelen van een robuust en goed ontworpen softwaresysteem dat voldoet aan de gestelde eisen en verwachtingen.

In de volgende secties zullen we verder ingaan op de specifieke onderdelen van een DCD, de betekenis ervan, en hoe deze iteratief kunnen worden opgebouwd met behulp van GRASP-patronen zoals controller, creator en expert. Daarnaast zullen we bespreken hoe systeemoperaties correct gedefinieerd en opgesplitst kunnen worden in deelverantwoordelijkheden binnen het DCD, en uiteindelijk hoe het DCD efficiënt kan worden omgezet naar Java-code.

# DCD ontwikkelen a.d.h.v. GRASP: Dobbelspel – Iteratie 1 “Speel spel”


### Inleiding

In dit gedeelte gaan we verder met het ontwikkelen van het Design Class Diagram (DCD) door gebruik te maken van GRASP-principes binnen de context van een dobbelspel. We starten met de eerste iteratie, waarin we de use case "Speel spel" in een vereenvoudigde vorm uitwerken. Hierbij worden enkele complexiteiten tijdelijk achterwege gelaten om de focus te houden op de kernprincipes, die later verder worden ontwikkeld.

### Context

We gebruiken het dobbelspel als context voor het ontwikkelen van het DCD. Deze context biedt een duidelijk kader waarin we de interacties tussen verschillende objecten kunnen modelleren. De analysefase heeft ons al voorzien van basisproducten zoals het domeinmodel, systeemsequentiediagrammen (SSD) en operation contracts (OC’s), die als uitgangspunt dienen voor het ontwerpproces.

### Resultaat Analyse

#### Systeemsequentiediagram (SSD)

Het SSD biedt een visuele weergave van de interacties tussen de actor en het systeem tijdens de use case "Speel spel". Het beschrijft de volgorde van berichten die tussen de actor en het systeem worden uitgewisseld.

#### Domeinmodel

Het domeinmodel identificeert de kernconcepten en hun relaties binnen het dobbelspel. Het definieert de belangrijkste klassen en hun onderlinge associaties, wat de basis vormt voor het ontwerpklassendiagram.

#### Operation Contracts (OC’s)

Operation Contracts specificeren de voorwaarden en resultaten van systeemoperaties. Ze beschrijven wat er gebeurt wanneer een bepaalde operatie wordt uitgevoerd, inclusief de precondities en postcondities die van toepassing zijn.

### Stappenplan Uitwerken voor Systeemoperatie 1

We beginnen met het uitwerken van de eerste systeemoperatie uit het SSD. Dit proces bestaat uit drie hoofdfasen: DOING/KNOWING, Bepaal Methode en Opsplitsen in Deelverantwoordelijkheden.

#### Stap 1: DOING/KNOWING

**Definitie van Systeemoperatie:** Een systeemoperatie is de boodschap die op een pijl op het SSD staat en die pijl loopt van de actor naar het systeem.

**Analyse van de Systeemoperatie `startNieuwSpel()`:**

1. **DOING-verantwoordelijkheid:**
    - Aangezien er een Operation Contract (OC) is voor deze systeemoperatie, duidt dit op een _DOING_-verantwoordelijkheid.
2. **KNOWING-verantwoordelijkheid:**
    - Er is geen terugkeerpijl op het SSD voor `startNieuwSpel()`, wat betekent dat er geen _KNOWING_-verantwoordelijkheid is.

**Conclusie:** De systeemoperatie `startNieuwSpel()` heeft enkel een _DOING_-verantwoordelijkheid.

#### Stap 2: Bepaal Methode

**Definitie van Methode:** Voor elke verantwoordelijkheid uit stap 1 definiëren we een methode.

- **Naam:** De naam van de systeemoperatie (`startNieuwSpel`) wordt hergebruikt als de naam van de methode.
- **Parameters:** Er zijn geen parameters nodig omdat er geen informatie van buitenaf nodig is.
- **Returntype:** Voor een _DOING_-verantwoordelijkheid is het returntype altijd `void`.

**Conclusie:** De methode wordt gedefinieerd als `startNieuwSpel(): void`.

#### Stap 3: Opsplitsen in Deelverantwoordelijkheden

**Controller Pattern Toepassen:**

1. **Naam:** Controller
2. **Probleem:** Identificeren welk object, naast de User Interface, verantwoordelijk is voor het ontvangen en coördineren van een systeemoperatie.
3. **Oplossing:** Wijs de verantwoordelijkheid toe aan een klasse die het volledige systeem representeert, genaamd `DomeinController`.

**Toepassing:** De `DomeinController` klasse ontvangt de systeemoperatie `startNieuwSpel()` en coördineert de creatie van de benodigde objecten binnen het domein.

**Creator Pattern Toepassen:**

1. **Naam:** Creator
2. **Probleem:** Bepalen welke klasse verantwoordelijk is voor het aanmaken van nieuwe instanties van een andere klasse.
3. **Oplossing:** Ken de verantwoordelijkheid toe aan een klasse die instantiates beheert, zoals de `DomeinController` voor de `Spel` klasse.

**Toepassing:** De `DomeinController` is verantwoordelijk voor het aanmaken van een nieuw `Spel` object. Dit gebeurt via de constructor van de `Spel` klasse zonder parameters, aangezien het `Spel` object zelf de initiële waarden bepaalt.

**Expert Pattern Toepassen:**

1. **Naam:** Expert
2. **Probleem:** Bepalen welke klasse de nodige informatie bezit om een verantwoordelijkheid uit te voeren.
3. **Oplossing:** Ken de verantwoordelijkheid toe aan de klasse die alle benodigde informatie bezit.

**Toepassing:** Het `Spel` object is verantwoordelijk voor het aanmaken van `Dobbelsteen` objecten, aangezien het `Spel` object de expertise bezit om deze objecten te beheren en te initialiseren.

**Conclusie:** Door het toepassen van de GRASP-patronen `Controller`, `Creator` en `Expert` hebben we de verantwoordelijkheden correct toegewezen aan de respectieve klassen binnen het DCD. De `DomeinController` ontvangt de systeemoperatie, creëert een nieuw `Spel` object, en het `Spel` object beheert de creatie en associatie van `Dobbelsteen` objecten.

### Stappenplan Uitwerken voor Systeemoperatie 2

We herhalen dezelfde stappen voor de tweede systeemoperatie `rolDobbelstenen()`.

#### Stap 1: DOING/KNOWING

**Analyse van de Systeemoperatie `rolDobbelstenen()`:**

1. **DOING-verantwoordelijkheid:**
    
    - Aangezien er een Operation Contract (OC) is voor deze systeemoperatie, duidt dit op een _DOING_-verantwoordelijkheid.
2. **KNOWING-verantwoordelijkheid:**
    
    - Er zijn terugkeerpijlen op het SSD voor `rolDobbelstenen()`, wat duidt op een _KNOWING_-verantwoordelijkheid.

**Conclusie:** De systeemoperatie `rolDobbelstenen()` heeft zowel een _DOING_ als een _KNOWING_-verantwoordelijkheid.

#### Stap 2: Bepaal Methode

**Definitie van Methoden:**

1. **DOING-verantwoordelijkheid:**
    
    - **Naam:** `rolDobbelstenen`
    - **Parameters:** Geen
    - **Returntype:** `void`
2. **KNOWING-verantwoordelijkheid:**
    
    - **Methode 1:**
        - **Naam:** `geefAantalOgenWorp`
        - **Parameters:** Geen
        - **Returntype:** `int`
    - **Methode 2:**
        - **Naam:** `geefScore`
        - **Parameters:** Geen
        - **Returntype:** `int`

**Conclusie:** Er worden drie methoden gedefinieerd:

1. `rolDobbelstenen(): void`
2. `geefAantalOgenWorp(): int`
3. `geefScore(): int`

#### Stap 3: Opsplitsen in Deelverantwoordelijkheden

**Controller Pattern Toepassen:**

- De `DomeinController` ontvangt de systeemoperaties `rolDobbelstenen()`, `geefAantalOgenWorp()`, en `geefScore()`.

**Expert Pattern Toepassen:**

1. **Voor `rolDobbelstenen()`:**
    
    - De `DomeinController` delegeert deze verantwoordelijkheid aan het `Spel` object.
    - Het `Spel` object is verantwoordelijk voor het aanroepen van de `rol` methoden op de `Dobbelsteen` objecten.
2. **Voor `geefAantalOgenWorp()`:**
    
    - De `DomeinController` delegeert deze verantwoordelijkheid aan het `Spel` object.
    - Het `Spel` object haalt de benodigde informatie op van de `Dobbelsteen` objecten en retourneert deze aan de `DomeinController`.
3. **Voor `geefScore()`:**
    
    - De `DomeinController` delegeert deze verantwoordelijkheid aan het `Spel` object.
    - Het `Spel` object berekent de score op basis van de huidige en eerste worp en retourneert deze aan de `DomeinController`.

**Conclusie:** Door het toepassen van de `Expert`-patroon hebben we de verantwoordelijkheden correct toegewezen aan de `Spel` en `Dobbelsteen` klassen. De `DomeinController` fungeert als coördinator die de systeemoperaties ontvangt en de nodige acties delegeert aan de juiste klassen binnen het domein.

### Stappenplan Uitwerken voor Stopvoorwaarde van de Loop

Naast de systeemoperaties moeten we ook de stopvoorwaarde van de loop op het SSD verwerken in het DCD.

#### Stap 1: DOING/KNOWING

**Analyse van de Stopvoorwaarde:**

- De stopvoorwaarde bepaalt hoe vaak de communicatie in het frame wordt herhaald.
- Deze stopvoorwaarde wordt gestuurd door het systeem, gebaseerd op de businesslogica.
- Dit resulteert in een _KNOWING_-verantwoordelijkheid omdat er informatie uit het domein nodig is.

**Conclusie:** De stopvoorwaarde levert een systeemoperatie op die een _KNOWING_-verantwoordelijkheid heeft.

#### Stap 2: Bepaal Methode

**Definitie van Methode:**

- **Naam:** `isEindeSpel`
- **Parameters:** Geen
- **Returntype:** `boolean`

**Conclusie:** De methode wordt gedefinieerd als `isEindeSpel(): boolean`.

#### Stap 3: Opsplitsen in Deelverantwoordelijkheden

**Controller Pattern Toepassen:**

- De `DomeinController` ontvangt de systeemoperatie `isEindeSpel()`.

**Expert Pattern Toepassen:**

- De `DomeinController` delegeert deze verantwoordelijkheid aan het `Spel` object.
- Het `Spel` object bepaalt op basis van de `score` of het einde van het spel is bereikt.

**Conclusie:** De `isEindeSpel()` methode wordt toegevoegd aan de `DomeinController`, die de verantwoordelijkheid delegeert aan het `Spel` object. Het `Spel` object berekent de status van het spel op basis van de huidige score en retourneert deze informatie aan de `DomeinController`.

### Eindconclusie van Iteratie 1

Na het doorlopen van de eerste iteratie hebben we het Design Class Diagram (DCD) succesvol uitgebreid door de systeemoperaties `startNieuwSpel()`, `rolDobbelstenen()`, en de stopvoorwaarde `isEindeSpel()` te verwerken. Door het toepassen van de GRASP-patronen `Controller`, `Creator` en `Expert` hebben we de verantwoordelijkheden correct toegewezen aan de respectieve klassen binnen het DCD. Hierdoor is het ontwerp nu klaar om verder geïmplementeerd te worden in Java-code.

### Visueel Overzicht van het DCD na Iteratie 1

Het DCD toont nu de volgende klassen en hun onderlinge relaties:

- **DomeinController**
    
    - Methoden:
        - `startNieuwSpel(): void`
        - `rolDobbelstenen(): void`
        - `geefAantalOgenWorp(): int`
        - `geefScore(): int`
        - `isEindeSpel(): boolean`
    - Associaties:
        - Bevat een referentie naar het `Spel` object.
- **Spel**
    
    - Attributen:
        - `score: int`
        - `eersteWorp: int`
    - Methoden:
        - `rolDobbelstenen(): void`
        - `geefAantalOgenWorp(): int`
        - `geefScore(): int`
    - Associaties:
        - Bevat twee `Dobbelsteen` objecten.
- **Dobbelsteen**
    
    - Attributen:
        - `aantalOgen: int`
    - Methoden:
        - `rol(): void`

Dit overzicht illustreert hoe de verantwoordelijkheden en methoden zijn toegewezen aan de respectieve klassen, conform de GRASP-principes, en hoe deze klassen samenwerken binnen het systeem om de use case "Speel spel" te ondersteunen.

## Conclusie

In dit gedeelte hebben we de eerste iteratie van het ontwikkelen van het Design Class Diagram (DCD) voor het dobbelspeluse case "Speel spel" afgerond. Door het toepassen van Responsibility Driven Design (RDD) en de GRASP-patronen `Controller`, `Creator` en `Expert`, hebben we de verantwoordelijkheden systematisch toegewezen aan de juiste klassen. Dit proces heeft geleid tot een gestructureerd en goed ontworpen DCD dat klaar is voor verdere ontwikkeling en implementatie in Java-code.

In de volgende secties zullen we doorgaan met de volgende iteraties, waarbij we nieuwe systeemoperaties toevoegen en het DCD verder verfijnen. We zullen blijven toepassen van de GRASP-principes om een robuust en onderhoudbaar softwaresysteem te bouwen dat voldoet aan de gestelde eisen en verwachtingen.
# Van DCD naar Java

Uitstekend, laten we verder gaan met het theoretisch uitleggen van het proces van het vertalen van een Design Class Diagram (DCD) naar Java-softwareklassen. We zullen ons richten op de kernconcepten en methodologieën, waarbij we concrete voorbeelden vermijden om de uitleg zo algemeen en toepasbaar mogelijk te maken.

## DCD naar Java-softwareklassen Vertalen

### De Basis: Klasse, Attribuut en Methode Definiëren

Bij het vertalen van een DCD naar Java-code is het essentieel om de fundamentele bouwstenen van objectgeoriënteerd programmeren (OOP) correct te implementeren. Deze bouwstenen zijn klassen, attributen en methoden.

#### Klassen

Een **klasse** in Java vertegenwoordigt een blauwdruk voor objecten binnen het systeem. Elke klasse bevat:

- **Attributen**: Eigenschappen die de staat van een object beschrijven.
- **Methoden**: Gedragsfuncties die de functionaliteit van de klasse definiëren.

**Definitie van een Klasse:**

```java
package domein;

public class KlasseNaam {
    // Attributen
    private Datatype attribuutNaam1;
    private Datatype attribuutNaam2;

    // Constructor
    public KlasseNaam() {
        // Initialisatie van attributen
    }

    // Methoden
    public void methodeNaam() {
        // Implementatie van de methode
    }

    // Getters en Setters
    public Datatype getAttribuutNaam1() {
        return attribuutNaam1;
    }

    private void setAttribuutNaam1(Datatype attribuutNaam1) {
        this.attribuutNaam1 = attribuutNaam1;
    }
}
```

**Belangrijke Aspecten:**

1. **Package Declaratie**: Klassen worden georganiseerd binnen packages voor betere modulariteit en organisatie. In dit geval wordt de klasse geplaatst in de package `domein`.
2. **Toegankelijkheidsmodificatoren**: Attributen worden doorgaans `private` gemaakt om **encapsulatie** te bevorderen, wat betekent dat de interne staat van het object niet direct toegankelijk is vanuit andere klassen.
3. **Constructors**: Speciale methoden die worden aangeroepen bij het aanmaken van een nieuw object. Ze initialiseren de attributen van de klasse.
4. **Methoden**: Functies die gedragingen definiëren die objecten van de klasse kunnen uitvoeren.
5. **Getters en Setters**: Publieke methoden die gecontroleerde toegang bieden tot privé-attributen.

### Associaties, Delegeren, Constructors en Verzamelingen

Naast de basiscomponenten van klassen, zijn er aanvullende concepten die essentieel zijn voor een correct ontwerp en implementatie.

#### Associaties

**Associaties** in een DCD geven de relaties aan tussen verschillende klassen. In Java worden deze associaties vaak gemodelleerd als attributen binnen de betrokken klassen.

- **Eendelig**: Een klasse heeft een referentie naar een ander enkelvoudig object.
    
    ```java
    public class KlasseA {
        private KlasseB klasseB;
    }
    ```
    
- **Veelvoudig**: Een klasse heeft een verzameling van objecten van een andere klasse, vaak geïmplementeerd met behulp van collecties zoals `List`.
    
    ```java
    import java.util.List;
    import java.util.ArrayList;
    
    public class KlasseA {
        private List<KlasseB> klasseBList;
    
        public KlasseA() {
            klasseBList = new ArrayList<>();
        }
    }
    ```
    

**Belangrijke Overwegingen:**

1. **Multipliciteit**: Bepaalt het aantal instanties van een klasse dat kan deelnemen aan de relatie. Dit beïnvloedt het datatype van het attribuut (enkelvoudig vs. verzameling).
2. **Visibiliteit**: Associaties worden meestal als `private` gemodelleerd om encapsulatie te waarborgen.
3. **Navigeerbaarheid**: Geeft aan welke kant van de associatie toegankelijk is. Dit wordt in Java gerepresenteerd door de aanwezigheid of afwezigheid van attributen in de betrokken klassen.

#### Delegeren

**Delegeren** is het proces waarbij een klasse de verantwoordelijkheid overdraagt voor een bepaalde taak aan een andere klasse. Dit bevordert een lage koppeling en hoge cohesie binnen het systeem.

**Voorbeeld van Delegeren:**

```java
public class KlasseA {
    private KlasseB klasseB;

    public void voerTaakUit() {
        klasseB.verwerk();
    }
}

public class KlasseB {
    public void verwerk() {
        // Implementatie van de taak
    }
}
```

In dit voorbeeld draagt `KlasseA` de verantwoordelijkheid voor het verwerken van een taak over aan `KlasseB` door de methode `verwerk()` aan te roepen.

#### Constructors

**Constructors** zijn speciale methoden die worden gebruikt om nieuwe objecten van een klasse te initialiseren. Ze hebben geen returntype en de naam komt overeen met de naam van de klasse.

**Voorbeeld van een Constructor:**

```java
public class KlasseA {
    private int waarde;

    public KlasseA(int waarde) {
        this.waarde = waarde;
    }
}
```

**Belangrijke Aspecten:**

1. **Initialisatie**: Constructors zorgen ervoor dat objecten in een geldige staat worden aangemaakt door attributen te initialiseren.
2. **Overloading**: Een klasse kan meerdere constructors hebben met verschillende parameters om flexibiliteit te bieden bij objectcreatie.

#### Verzamelingen

In Java worden **verzamelingen** vaak geïmplementeerd met behulp van de `List` interface en de `ArrayList` klasse. Ze worden gebruikt om meerdere objecten van een bepaalde klasse te beheren.

**Voorbeeld van een Verzamelingsattribuut:**

```java
import java.util.List;
import java.util.ArrayList;

public class KlasseA {
    private List<KlasseB> klasseBList;

    public KlasseA() {
        klasseBList = new ArrayList<>();
    }

    public void voegKlasseBToe(KlasseB klasseB) {
        klasseBList.add(klasseB);
    }
}
```

**Belangrijke Overwegingen:**

1. **Initialisatie**: Het is essentieel om de verzameling te initialiseren in de constructor om `NullPointerException` te voorkomen.
2. **Encapsulatie**: Toegang tot de verzameling wordt vaak gecontroleerd via methoden zoals `voegKlasseBToe`.

### Volledig Ontwerp Implementeren

Na het definiëren van de klassen, attributen, methoden en associaties, kan het volledige ontwerp worden geïmplementeerd in Java-code. Dit omvat het zorgen voor correcte encapsulatie, methodesignaturen en de juiste toewijzing van verantwoordelijkheden aan de klassen.

**Implementatie Stappen:**

1. **Definieer Klassen**: Maak Java-klassen aan die overeenkomen met de klassen in het DCD.
2. **Definieer Attributen**: Voeg privé-attributen toe aan de klassen volgens het DCD.
3. **Implementeer Constructors**: Zorg ervoor dat elke klasse een constructor heeft die de attributen correct initialiseert.
4. **Implementeer Methoden**: Voeg methoden toe aan de klassen die overeenkomen met de methodesignaturen in het DCD.
5. **Modelleer Associaties**: Voeg attributen toe aan de klassen om de relaties tussen klassen te vertegenwoordigen, gebruikmakend van enkelvoudige referenties of verzamelingen.
6. **Encapsulatie**: Voeg getters en setters toe waar nodig, waarbij setters vaak `private` zijn om de integriteit van het object te waarborgen.
7. **Delegeren**: Zorg ervoor dat methoden die verantwoordelijkheden overdragen correct communiceren met de relevante objecten.

### Uitvoerbare Applicatie

Naast de domeinklassen is het vaak noodzakelijk om een uitvoerbare klasse te hebben die fungeert als het startpunt van de applicatie. Deze klasse bevat de `main`-methode die de initiële objecten aanmaakt en de systeemoperaties aanroept.

**Voorbeeld van een Uitvoerbare Klasse:**

```java
package cui;

import domein.DomeinController;

public class Applicatie {
    public static void main(String[] args) {
        new Applicatie().start();
    }

    private void start() {
        // Aanmaken van het aanspreekpunt van de domeinlaag
        DomeinController controller = new DomeinController();
        controller.startNieuwSpel();

        // Uitvoeren van systeemoperaties
        while (!controller.isEindeSpel()) {
            controller.rolDobbelstenen();
            System.out.printf("Aantal ogen: %d%n", controller.geefAantalOgenWorp());
        }

        System.out.printf("Score: %d%n", controller.geefScore());
    }
}
```

**Belangrijke Aspecten:**

1. **Aanmaken van Controller**: De uitvoerbare klasse maakt een instantie aan van de `DomeinController`, die fungeert als het centrale aanspreekpunt voor systeemoperaties.
2. **Aanroepen van Methoden**: Via de controller worden systeemoperaties aangeroepen die de businesslogica uitvoeren.
3. **Interactieve Loop**: Een lus kan worden gebruikt om continue interactie met het systeem te simuleren, gebaseerd op voorwaarden die door de businesslogica worden bepaald.
4. **Invoer- en Uitvoeroperaties**: De uitvoerbare klasse kan verantwoordelijk zijn voor het weergeven van informatie aan de gebruiker via console-uitvoer of een andere vorm van presentatie.

### Conclusie

Het vertalen van een Design Class Diagram (DCD) naar Java-softwareklassen vereist een systematische aanpak waarbij de fundamentele OOP-concepten correct worden geïmplementeerd. Door zorgvuldig klassen, attributen, methoden en associaties te definiëren en verantwoordelijkheden toe te wijzen aan de juiste klassen, kan een robuust en onderhoudbaar softwaresysteem worden ontwikkeld. Encapsulatie, delegatie en het gebruik van verzamelingen zijn cruciale aspecten die bijdragen aan de structuur en functionaliteit van de applicatie.

In de volgende secties zullen we dieper ingaan op geavanceerdere ontwerpprincipes en -patronen, evenals op de implementatie van systeemoperaties en het omzetten van het volledige DCD naar een werkende Java-codebasis.
# DCD: ontwerp aanpassen met _private_ methodes

- Tijdens het implementeren van het ontwerp hebben we verschillende **private** methodes toegevoegd om de code overzichtelijker en herbruikbaarder te maken.
- Methodes toevoegen in de code om de code beter te maken is toegestaan, maar zet deze methodes dan wel `private`.
- Het is **wel belangrijk** om het DCD daarna te **updaten**. Door de private methodes ook toe te voegen aan het DCD, zorgen we ervoor dat het ontwerp en de implementatie op één lijn blijven.


![](20250106102755.png)
# Dobbelspel – Iteratie 2 – _Registreer_

Uitstekend, laten we het volgende deel van het hoofdstuk "Ontwikkel een applicatie" theoretischer benaderen. We zullen de inhoud structureren en verduidelijken, met een nadruk op de onderliggende principes en methodologieën, zonder specifieke concrete voorbeelden te gebruiken.

## Iteratieve Ontwikkeling: Van Eerste naar Tweede Iteratie

### Inleiding

Na het succesvol afronden van de eerste iteratie, waarin zowel het ontwerp als de implementatie van de eerste use case zijn voltooid, is het tijd om door te gaan naar de tweede iteratie. Iteratief ontwikkelen betekent dat we het systeem stap voor stap verder verfijnen en uitbreiden, waarbij elke iteratie gericht kan zijn op een ander aspect of alternatief verloop van de use cases.

### Overgang naar de Tweede Iteratie

Bij het starten van een nieuwe iteratie volgen we dezelfde gestructureerde aanpak als in de eerste iteratie. Dit omvat het doorlopen van alle fasen: **analyse**, **ontwerp**, **implementatie**, en **testen**. Elke iteratie bouwt voort op de voorgaande, waarbij we nieuwe use cases toevoegen of bestaande use cases uitbreiden.

In de tweede iteratie richten we ons op een alternatieve use case, aangeduid als "**Registreer**". Deze use case kan een eigen Systeemsequentiediagram (SSD) hebben, wat ons een nieuw perspectief biedt op de interacties binnen het systeem.

### Voorbereiding op de Tweede Iteratie

Voordat we aan de ontwerpfase van de tweede iteratie beginnen, is het essentieel om de producten uit de analysefase te herzien. Dit omvat het bekijken van de resultaten van de systeemsequentiediagrammen, domeinmodellen, en operation contracts (OC’s) die specifiek zijn voor de use case "Registreer". Deze documenten vormen de basis waarop het ontwerp wordt opgebouwd.

## Stappenplan voor het Ontwerpen van Systeemoperaties

Net als in de eerste iteratie, volgen we een driestappenplan voor elke systeemoperatie binnen de use case. Dit zorgt voor een consistente en systematische aanpak bij het ontwikkelen van het ontwerpklassendiagram (DCD).

### Stap 1: Identificeren van DOING en KNOWING Verantwoordelijkheden

Het eerste doel van deze stap is het bepalen van de aard van elke systeemoperatie binnen de SSD. Dit wordt gedaan door te analyseren of de operatie een **DOING**-verantwoordelijkheid, een **KNOWING**-verantwoordelijkheid, of beide omvat.

1. **DOING-verantwoordelijkheid:**
    
    - **Criteria:**
        - Aanwezigheid van een Operation Contract (OC).
        - Functionaliteit die het bijhouden of manipuleren van domeinobjecten inhoudt.
    - **Conclusie:** Als aan de bovenstaande criteria wordt voldaan, kent de systeemoperatie een DOING-verantwoordelijkheid toe.
2. **KNOWING-verantwoordelijkheid:**
    
    - **Criteria:**
        - Aanwezigheid van een terugkeerpijl in het SSD.
    - **Conclusie:** Indien een terugkeerpijl aanwezig is, omvat de systeemoperatie een KNOWING-verantwoordelijkheid.

**Resultaat:** Voor elke systeemoperatie bepalen we of deze verantwoordelijk is voor het uitvoeren van acties (DOING), het verstrekken van informatie (KNOWING), of beide.

### Stap 2: Definiëren van Methodesignaturen

In deze stap vertalen we de geïdentificeerde verantwoordelijkheden naar methoden binnen de klassen. Dit omvat het vaststellen van de juiste methodenamen, parameters, en returntypes.

1. **DOING-verantwoordelijkheid:**
    
    - **Methodesignatuur:**
        - **Naam:** Beschrijft de actie die de methode uitvoert.
        - **Parameters:** Afhankelijk van de vereisten; vaak geen parameters als de actie zelfstandig is.
        - **Returntype:** `void`, aangezien de methode een actie uitvoert zonder een directe waarde terug te geven.
2. **KNOWING-verantwoordelijkheid:**
    
    - **Methodesignatuur:**
        - **Naam:** Beschrijft de informatie die wordt opgevraagd.
        - **Parameters:** Meestal geen parameters, tenzij aanvullende informatie nodig is om de gegevens te verstrekken.
        - **Returntype:** Het type van de teruggegeven informatie (bijv. `int`, `String`, `boolean`).

**Conclusie:** Elke verantwoordelijkheid resulteert in een specifieke methodesignatuur die nauwkeurig de functionaliteit en gegevensstroom binnen het systeem weergeeft.

### Stap 3: Toewijzen van Verantwoordelijkheden aan Klassen

De laatste stap in het stappenplan is het toewijzen van de gedefinieerde methoden aan de juiste klassen binnen het DCD. Hierbij maken we gebruik van GRASP-principes om verantwoordelijkheden effectief te delegeren.

1. **Controller Pattern Toepassen:**
    
    - **Doel:** Identificeren welke klasse verantwoordelijk is voor het ontvangen en coördineren van systeemoperaties.
    - **Oplossing:** Wijs deze verantwoordelijkheid toe aan een centrale controllerklasse die fungeert als het aanspreekpunt voor de domeinlaag.
2. **Creator Pattern Toepassen:**
    
    - **Doel:** Bepalen welke klasse verantwoordelijk is voor het creëren van nieuwe instanties van andere klassen.
    - **Oplossing:** Ken de verantwoordelijkheid toe aan een klasse die intensief gebruikmaakt van of een verzameling van de te creëren objecten beheert.
3. **Expert Pattern Toepassen:**
    
    - **Doel:** Toewijzen van verantwoordelijkheden aan de klasse die de meeste informatie bezit om die verantwoordelijkheid uit te voeren.
    - **Oplossing:** De klasse die het meest relevant is voor de taak, gebaseerd op zijn attributen en bestaande associaties.

**Conclusie:** Door het toepassen van deze patronen zorgen we voor een lage koppeling en hoge cohesie binnen het systeem, wat bijdraagt aan een robuust en onderhoudbaar ontwerp.

## Implementatie en Testen

Na het voltooien van de ontwerpfase in elke iteratie, volgt de implementatiefase waarin het ontwerpklassendiagram wordt vertaald naar daadwerkelijke Java-code. Dit omvat het definiëren van klassen, attributen, methoden, en het implementeren van de nodige logica volgens het ontwerp.

### Vertaling van DCD naar Java-klassen

1. **Klasse Definiëren:**
    - Implementeer elke klasse uit het DCD in Java, inclusief de juiste package declaraties en toegangsmodificatoren.
2. **Attribuut Implementatie:**
    - Definieer privé-attributen binnen de klasse volgens het DCD, met de juiste datatypes en namen.
3. **Methoden Implementeren:**
    - Voeg methoden toe die overeenkomen met de methodesignaturen uit het DCD, inclusief de juiste parameters en returntypes.
4. **Associaties Modelleren:**
    - Implementeer associaties tussen klassen door middel van referenties of verzamelingen, afhankelijk van de multipliciteit en navigeerbaarheid zoals gespecificeerd in het DCD.
5. **Encapsulatie Toepassen:**
    - Zorg voor getters en setters waar nodig, waarbij setters vaak `private` zijn om de integriteit van de objecten te waarborgen.

### Testen

Na implementatie volgt de testfase, waarin we verifiëren of de gecreëerde klassen en methoden correct functioneren volgens de specificaties uit het ontwerp. Dit omvat unit testing, integratietesting, en systeemtesten om ervoor te zorgen dat alle onderdelen van het systeem naadloos samenwerken en voldoen aan de gestelde eisen.

## Overgang naar de Tweede Iteratie: Use Case "Registreer"

Met de eerste iteratie volledig afgerond en getest, richten we ons nu op de tweede iteratie, die zich focust op de use case "**Registreer**". Deze use case introduceert nieuwe systeemoperaties en verantwoordelijkheden die moeten worden geanalyseerd, ontworpen, geïmplementeerd en getest.

### Analyse van de Use Case "Registreer"

Voordat we kunnen beginnen met het ontwerpproces, moeten we de producten uit de analysefase voor deze use case zorgvuldig bestuderen. Dit omvat het herzien van de systeemsequentiediagrammen, domeinmodellen, en operation contracts die specifiek zijn voor "Registreer". Deze documenten bieden inzicht in de vereiste functionaliteiten en de interacties tussen verschillende onderdelen van het systeem.

### Ontwerpfase voor Systeemoperaties

Voor elke systeemoperatie binnen de use case "Registreer" volgen we opnieuw het driestappenplan:

1. **Identificeren van DOING en KNOWING Verantwoordelijkheden:**
    - Bepaal of de operatie acties uitvoert, informatie verstrekt, of beide.
2. **Definiëren van Methodesignaturen:**
    - Ontwerp methoden die nauwkeurig de functionaliteit en gegevensuitwisseling weergeven.
3. **Toewijzen van Verantwoordelijkheden aan Klassen:**
    - Gebruik GRASP-principes om verantwoordelijkheden effectief te delegeren aan de juiste klassen.

### Implementatie van Verantwoordelijkheden

Na het voltooien van het ontwerpproces voor elke systeemoperatie, zetten we deze om in Java-code. Dit omvat het implementeren van de gedefinieerde methoden, het modelleren van associaties, en het toepassen van encapsulatie om de integriteit van de objecten te waarborgen.

### Testen en Validatie

Elke geïmplementeerde functionaliteit wordt grondig getest om te verzekeren dat deze voldoet aan de specificaties uit het ontwerp. Dit omvat het verifiëren van zowel de correcte uitvoering van acties (DOING) als het verstrekken van accurate informatie (KNOWING).

## Conclusie

Door iteratief te werken en elke fase zorgvuldig te doorlopen, bouwen we systematisch een robuust en goed ontworpen softwaresysteem. Het gebruik van theoretische principes zoals GRASP en Responsibility Driven Design (RDD) zorgt ervoor dat verantwoordelijkheden effectief worden toegewezen, wat resulteert in een onderhoudbare en schaalbare architectuur. Elke iteratie bouwt voort op de vorige, waarbij nieuwe functionaliteiten worden toegevoegd en bestaande functionaliteiten worden verfijnd, wat leidt tot een steeds completer en verfijnder systeem.

In de volgende secties zullen we verder ingaan op de specifieke systeemoperaties van de use case "Registreer", waarbij we de eerder besproken stappen en principes toepassen om een solide ontwerp en implementatie te garanderen.
# Dobbelspel – Iteratie 3 – Meld Aan


### Inleiding

In deze derde iteratie richten we ons op de use case "**Meld Aan**". Dit proces omvat het analyseren, ontwerpen en implementeren van systeemoperaties die gebruikers in staat stellen zich aan te melden bij het systeem. We volgen een iteratieve benadering, waarbij elke iteratie voortbouwt op de voorgaande om het systeem geleidelijk te verfijnen en uit te breiden.

### Stappenplan voor Systeemoperatie

Voor elke systeemoperatie binnen de use case "Meld Aan" hanteren we een driestappenplan: **Identificeren van Verantwoordelijkheden**, **Definiëren van Methodesignaturen**, en **Toewijzen van Verantwoordelijkheden aan Klassen**.

#### Systeemoperatie 1: `startAanmelden`

##### Stap 1: Identificeren van DOING en KNOWING Verantwoordelijkheden

- **DOING-verantwoordelijkheid:** Deze operatie initieert het aanmeldproces zonder directe interactie met domeinobjecten. Daarom kent `startAanmelden` geen DOING-verantwoordelijkheid toe.
- **KNOWING-verantwoordelijkheid:** Aangezien er geen terugkeerpijl of gegevensoverdracht is, heeft `startAanmelden` ook geen KNOWING-verantwoordelijkheid.

##### Conclusie:

Er zijn geen aanpassingen nodig aan het Design Class Diagram (DCD) voor `startAanmelden`.

#### Systeemoperatie 2: `meldAan`

##### Stap 1: Identificeren van DOING en KNOWING Verantwoordelijkheden

- **DOING-verantwoordelijkheid:** Het aanmeldproces vereist het valideren en bijhouden van gebruikersgegevens, wat wijst op een DOING-verantwoordelijkheid.
- **KNOWING-verantwoordelijkheid:** De operatie verstrekt informatie over de aangemelde gebruiker, wat een KNOWING-verantwoordelijkheid impliceert.

##### Conclusie:

De systeemoperatie `meldAan` omvat zowel DOING- als KNOWING-verantwoordelijkheden.

##### Stap 2: Definiëren van Methodesignaturen

- **DOING:**
    - **Naam:** `meldAan`
    - **Parameters:** `email: String`, `wachtwoord: String`
    - **Returntype:** `void`
- **KNOWING:**
    - **Naam:** `geefSpeler`
    - **Parameters:** Geen
    - **Returntype:** `SpelerDTO` (Data Transfer Object)

##### Stap 3: Toewijzen van Verantwoordelijkheden aan Klassen

- **Controller Pattern:** De `DomeinController` fungeert als de centrale coördinator voor systeemoperaties.
- **Creator Pattern:** De verantwoordelijkheid voor het creëren van een `Speler`-object wordt toegewezen aan de `SpelerRepository`.
- **Expert Pattern:** De `SpelerRepository` beheert de opslag en validatie van `Speler`-objecten.

**Data Transfer Object (DTO):** Een `SpelerDTO` wordt gebruikt om gegevens veilig over te dragen tussen de domeinlaag en de user interface, zonder directe blootstelling van domeinobjecten.

### Implementatie Overzicht

#### DomeinController

- **Verantwoordelijkheden:**
    - Ontvangen van aanmeldgegevens.
    - Delegatie aan `SpelerRepository` voor validatie en opslag.
    - Bewaren van de aangemelde speler.
    - Verstrekken van spelerinformatie via `SpelerDTO`.

#### SpelerRepository

- **Verantwoordelijkheden:**
    - Beheren van een collectie `Speler`-objecten.
    - Valideren van unieke e-mailadressen.
    - Zoeken en teruggeven van `Speler`-objecten op basis van aanmeldgegevens.

#### SpelerDTO

- **Functie:**
    - Bevat essentiële gegevens van een speler.
    - Verzekert dat alleen toegestane informatie wordt gedeeld met de user interface.

### Conclusie

Door het toepassen van GRASP-principes zoals **Controller**, **Creator**, en **Expert**, hebben we de verantwoordelijkheden effectief toegewezen aan de juiste klassen binnen het DCD. Het gebruik van een DTO waarborgt een veilige en gescheiden gegevensoverdracht tussen de domeinlaag en de user interface. Deze iteratieve aanpak zorgt voor een gestructureerde en onderhoudbare ontwikkeling van de use case "**Meld Aan**".

In de volgende stappen zullen we verdergaan met de implementatiefase en het testen van de gecreëerde functionaliteiten, waarbij we blijven bouwen op de eerder opgestelde ontwerpprincipes.
# Samenvatting
    
## Stap 1: DOING/KNOWING
    
>  - _Stap 1: Vertrek van het SSD en bepaal voor elke systeemoperatie (ook uit loop of alternatief verloop) de doing- en/of knowing-verantwoordelijkheden._

   - **DOING** = object(en) aanmaken/bijhouden/verwijderen of waarde(n) aanpassen.
        - _Algemene regel_:
            1. Als er een OC is, dan is er DOING-verantwoordelijkheid.
            2. Als de systeemoperatie functionaliteit bevat waarbij een domeinobject moet bijgehouden worden, is er DOING-verantwoordelijkheid.


   - **KNOWING** = waarde(n) teruggeven.
        - _Algemene regel_:
            1. Als de systeemoperatie op het SSD een returnpijl heeft, is er KNOWING-verantwoordelijkheid.
                
            2. Bij loop of alternatief verloop: als er data moet worden teruggegeven uit het domein, is er KNOWING-verantwoordelijkheid.

>
>		    1. Een systeemoperatie kan 0, 1 of **meerdere** verantwoordelijkheden hebben.
>		    2. Eén verantwoordelijkheid kan nooit tegelijk DOING én KNOWING zijn.
>		    3. Als er **geen** DOING of KNOWING-verantwoordelijkheid is,
>			    - zorgt de systeemoperatie **niet** voor een methode op het DCD. 
>			    - Geen aanpassingen in het domein dus. 
>			    - Die systeemoperatie zorgt alleen voor wijzigingen in de applicatie.
 >   
    
## Stap 2: Bepaal methode
    
>- _Stap 2: Definieer voor elke verantwoordelijkheid uit stap 1 een methode._
        
  - De definitie van een methode bevat:
        
       1. een betekenisvolle **naam**
       2. eventuele **parameters**
       3. een **returntype**
       
| **DOING**      |                                                                                                                                                                                     |
| -------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **naam**       | Moet betekenisvol zijn. Dekt de naam van het SSD de functionaliteit? Zo ja, hergebruik die naam. Anders bedenk je een nieuwe naam die overeenkomt met de benodigde functionaliteit. |
| **parameters** | Optioneel, alleen als nodig voor deze methode. Staan er op het SSD parameters? Bepaal of deze methode ze echt nodig heeft. Bepaal ook het datatype.                                 |
| **returntype** | `void`                                                                                                                                                                              |

| **KNOWING**    |                                                                                                                                                                                                     |
| -------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **naam**       | Moet betekenisvol zijn. Dekt de naam van het SSD de functionaliteit? Zo ja, hergebruik die naam. Anders bedenk je een nieuwe naam die overeenkomt met de benodigde functionaliteit.                 |
| **parameters** | Optioneel, alleen als nodig voor deze methode.                                                                                                                                                      |
| **returntype** | Bepaal het meest passende datatype voor de terug te geven waarde. _Opletten bij meerdere waardes_: - Allemaal hetzelfde datatype? _Array of List_ - Verschillende datatypes? _Groeperen in een DTO_ |

    
> **Methodes in de DomeinController** die gegevens retourneren naar de UI (publieke methodes) hebben als returntype:
   > 
   > - een primitief type
   > - een voorgedefinieerde Java-klasse (bv. `String`, `LocalDate`)
   > - een **DTO**
   > - of een verzameling (_Array_, _List_, …) van 1 van deze opties. 
   > 
 > De attributen van een DTO mogen ook alleen 1 van de bovenstaande opties als type bevatten.
    
## Stap 3: Opsplitsen in deelverantwoordelijkheden
    
>- _Stap 3: Splits de verantwoordelijkheid op in kleine deelverantwoordelijkheden en plaats ze in een gepaste klasse op het DCD._
    
### Stap 3A: Controller pattern toepassen
    
1. Voeg indien nodig de klasse `DomeinController` toe aan het DCD.
2. Voeg de methode uit stap 2 toe aan de `DomeinController`.
    
### Stap 3B: Deelverantwoordelijkheden toekennen aan de juiste klassen m.b.v. Creator en/of Expert**
    
#### Creator pattern
        
- _Moet er een instantie van een klasse aangemaakt worden?_

	1. **Is de klasse al op het DCD?**
            - Zo nee: neem de klasse over van het domeinmodel en vul bij elk attribuut het datatype in. Neem eventuele associaties over zonder extra info (nog geen associatienaam, rolnamen, multipliciteit).
    2. **Heeft de klasse een constructor met de juiste parameters?**
            - Zo nee: voeg de constructor toe, met de nodige parameters (incl. datatypes) om de instantie correct te kunnen aanmaken.
    3. **Bepaal welke klasse** de constructor zal oproepen en in welke methode dit gebeurt.
            - Bestaat die methode nog niet? Voeg deze toe (eventueel met parameters).
    4. **Bepaal wie** het nieuwe object zal bijhouden.
            - Was er een associatie op het domeinmodel die je eerder overnam? Werk die verder uit (navigeerbaarheid, visibiliteit, naam, multipliciteit).
            - Heb je geen associatie overgenomen in stap 1?  
                  a. Bepaal wie de instantie bijhoudt.  
              b. Voeg een associatie toe tussen deze klassen.  
              c. Werk deze associatie volledig uit: navigeerbaarheid, visibiliteit, naam, multipliciteit.
#### Expert pattern
        
>- _Wie is verantwoordelijk om een bepaalde actie uit te voeren?_
   >         
   >- **Ken** de verantwoordelijkheid toe aan de Information Expert, de klasse die alle benodigde info heeft om de verantwoordelijkheid te realiseren.
            
   1. Kijk eerst op het DCD of daar klassen zijn die in aanmerking komen.
        - Zo ja: voeg de methode aan deze klasse toe.
  2. In tweede instantie kan het domeinmodel inspiratie geven voor een geschikte klasse.
        - Zo ja: Voeg de klasse toe aan het DCD, denk na over associaties voor je de methode toevoegt.
  3. Mogelijks maak je een nieuwe klasse met een duidelijke rol en verantwoordelijkheid (denk weer aan associaties).

		
- **Eens je de klasse hebt gevonden die EXPERT is** over alle info om de verantwoordelijkheid te realiseren, 
	- controleer je of de `DomeinController` expert is over **die** klasse. Alleen dan kan de DomeinController de net toegevoegde methode aanroepen.    
 - Is de DomeinController **geen** expert? 
	 - Ga dan op zoek naar de “ketting” tussen de DomeinController en de klasse en voeg bij elke stap in de ketting een methode toe.