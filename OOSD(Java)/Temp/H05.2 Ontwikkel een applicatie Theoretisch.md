
[Bijhorende powerpoint](OOSD1_SlidesH5.ppsx)
#  Doelstellingen


- om **alle onderdelen** van een DCD correct te benoemen  
- om **de betekenis** van een DCD te begrijpen  
- om **een DCD op te bouwen** op iteratieve wijze met behulp van 3 GRASP-patronen: *controller*, *creator* en *expert*  
- om **een systeemoperatie** te definiëren met de correcte verantwoordelijkheid (*doing*/*knowing*)  
- om de systeemoperaties op te splitsen in **deelverantwoordelijkheden** die op het DCD kunnen geplaatst worden  
- om **een DCD om te zetten naar Java-code**  


# Inleiding

Softwareontwikkeling volgt een **iteratief proces**, waarbij elke iteratie een reeks gestructureerde fasen doorloopt. Deze fasen worden doorgaans weergegeven in een iteratiemodel, zoals geïllustreerd in de bijgevoegde figuur.

## Requirement Analysis

De eerste fase is de **Requirement Analysis**. Het grondig begrijpen van de behoeften van de klant en het vastleggen van duidelijke afspraken zijn cruciaal in deze fase. Dit vormt de basis voor alle volgende stappen in het ontwikkelingsproces.

## Design, Implementation en Testing

De volgende drie fasen—**Design**, **Implementation** en **Testing**—zijn essentieel binnen het iteratieve ontwikkelingsproces en worden behandeld in het opleidingsonderdeel **Object Oriented Software Development I**.

- **Implementation**: Eerder lag de focus op deze fase, waarbij de nadruk lag op het vertalen van functionele vereisten naar programmeerinstructies in Java.
    
- **Design**: Deze fase bevindt zich tussen de analyse en de implementatie. Op basis van de resultaten van de Requirement Analysis worden ontwerpdocumenten opgesteld, waaronder:
    
    - **Use Case Diagram (UCD)**
    - **Use Cases**
    - **Domeinmodel**
    - **System Sequence Diagrams (SSD)** en bijbehorende **Operation Contracts (OC’s)**
    
    Het ontwerp moet nauw aansluiten bij de analyse om een coherente en effectieve implementatie mogelijk te maken.
    

### Design Class Diagram (DCD)

In de ontwerpfase wordt een **Design Class Diagram (DCD)** ontwikkeld, dat de structuur en relaties van de systeemklassen definieert. Dit diagram dient als blauwdruk voor de implementatiefase, waarin de klassendiagrammen worden vertaald naar daadwerkelijke Java-klassen.

- **Programmeertaal**: Hoewel de ontwerpfase doorgaans de keuze van programmeertaal omvat, is in deze context de keuze voor **Java** vooraf bepaald.
    
- **Detailniveau**: Het DCD wordt gedetailleerd uitgewerkt om alle benodigde klassen, attributen en methoden nauwkeurig te specificeren, wat een soepele overgang naar de implementatiefase bevordert.
    

![Iteratief Ontwikkelingsproces](20250105230514.png)

## Conclusie

Door een iteratieve benadering te hanteren, waarbij elke fase systematisch wordt doorlopen, wordt een robuust en onderhoudbaar softwaresysteem ontwikkeld. De overgang van Requirement Analysis naar Design, en vervolgens naar Implementation en Testing, zorgt voor een gestructureerde en gecontroleerde ontwikkeling, waarbij elke stap voortbouwt op de vorige om aan de gestelde eisen te voldoen.


# Ontwerpklassendiagram

In de volgende secties zullen we dieper ingaan op de specifieke aspecten van de ontwerpfase, met een focus op het ontwikkelen van het Design Class Diagram en het voorbereiden van de implementatiefase.
Uitstekend, laten we het concept van het **Design Class Diagram (DCD)** op een theoretische en beknopte wijze bespreken, waarbij de focus ligt op de kernprincipes zonder in te gaan op concrete voorbeelden.
## Inleiding

Een **Design Class Diagram (DCD)** is een fundamenteel onderdeel van het softwareontwerpproces binnen de objectgeoriënteerde paradigma. Het DCD biedt een gedetailleerde weergave van de klassen in een systeem, inclusief hun attributen, methoden en onderlinge relaties. Dit diagram fungeert als een brug tussen de analysefase en de implementatiefase, waarbij het conceptuele model wordt vertaald naar een technisch ontwerp dat direct kan worden geïmplementeerd in een programmeertaal zoals Java.

## Verschil tussen Analyse- en Ontwerpniveau

Het onderscheid tussen het **analyseniveau** en het **ontwerpniveau** is cruciaal:

- **Analyzeniveau**:
    
    - Richt zich op de **conceptuele structuur** van het systeem.
    - Gebruikt abstracte klassen en relaties zonder specifieke technische details.
    - Doel is het begrijpen van de vereisten en het vastleggen van de domeinconcepten.
- **Ontwerpniveau**:
    
    - Verfijnt het analisemodel met **gedetailleerde technische specificaties**.
    - Definieert concrete datatypes, methodesignaturen, constructors en gedetailleerde associaties.
    - Bereidt het model voor op directe implementatie in code.

## UML-diagrammen: Structuur vs. Gedrag

**Unified Modeling Language (UML)** onderscheidt twee hoofdtypen diagrammen:

1. **Structuurdiagrammen**:
    
    - Modelleren de statische aspecten van het systeem.
    - Voorbeelden: Class Diagrams, Component Diagrams.
    - Focus op klassen, attributen, methoden en relaties.
2. **Gedragsdiagrammen**:
    
    - Modelleren de dynamische aspecten van het systeem.
    - Voorbeelden: Use Case Diagrams, Sequence Diagrams.
    - Focus op interacties, workflows en gedrag over tijd.

## Kenmerken van een Design Class Diagram (DCD)

- **Klassen en Attributen**:
    
    - Representeren de entiteiten binnen het systeem.
    - Attributen beschrijven de eigenschappen van een klasse.
- **Methoden**:
    
    - Definiëren het gedrag en de functionaliteit van een klasse.
- **Associaties**:
    
    - Beschrijven de relaties tussen klassen.
    - Specifiek met rollen, multipliciteit, navigabiliteit en richting.
- **Encapsulatie**:
    
    - Attributen zijn meestal privé (`private`), toegankelijk via getters en setters.
    - Bevordert gegevensbescherming en integriteit.

## Associaties tussen Klassen

Associaties geven de relaties tussen klassen weer en worden gekenmerkt door:

1. **Rollen**:
    - Beschrijven de functie van elke klasse binnen de associatie.
2. **Multipliciteit**:
    - Specificeert het aantal instanties dat kan deelnemen aan de relatie.
    - Voorbeelden: 1, 0..1, _, 1.._, n..m.
3. **Naamgeving**:
    - Benoemt de relatie vanuit de perspectieven van beide klassen.
4. **Visibiliteit**:
    - Bepaalt de toegankelijkheid van de associatie, doorgaans `private`.
5. **Navigabiliteit**:
    - Geeft aan vanuit welke klasse de associatie kan worden gevolgd.
    - Enkelzijdig of dubbelzijdig.

## Preciseren van een Associatie

Om een associatie volledig te definiëren, moeten de volgende aspecten worden gespecificeerd:

1. **Rollen**:
    - Benoemen hoe de betrokken klassen elkaar benaderen binnen de relatie.
2. **Multipliciteit**:
    - Duidelijke indicatie van hoeveel instanties van elke klasse deel kunnen nemen.
3. **Naamgeving**:
    - Helder benoemen van de relatie om semantische duidelijkheid te bieden.
4. **Visibiliteit**:
    - Beperk toegang tot de associatie indien nodig om encapsulatie te waarborgen.
5. **Navigabiliteit**:
    - Specificeer vanuit welke klasse de associatie kan worden gevolgd, wat de richting van interactie bepaalt.

## Van DCD naar Java-code

### Equivalente Klassen

Elke klasse in het DCD correspondeert direct met een Java-klasse. Belangrijke aspecten omvatten:

- **Naamgeving**: Klassenamen moeten consistent zijn tussen DCD en Java.
- **Attributen**: Private attributen in het DCD worden vertaald naar private velden in Java.
- **Methodesignaturen**: Methoden in het DCD moeten nauwkeurig worden geïmplementeerd in Java, inclusief correcte parameters en returntypes.
- **Constructors**: Zorg voor passende constructors die de attributen initialiseren volgens het DCD.

### Attributen en Associaties in Java

- **Attributen**:
    - Direct vertaald naar private velden in de Java-klasse.
- **Associaties**:
    - Enkelzijdige associaties worden gemodelleerd als referentieattributen.
    - Veelzijdige associaties vereisen collecties zoals `List<>` of arrays om meerdere instanties te beheren.
- **Encapsulatie**:
    - Attributen zijn privé en toegankelijk via publieke getters en eventueel setters.

### Implementatie Overwegingen

- **Consistentie**:
    - Zorg ervoor dat alle elementen van het DCD correct en volledig worden geïmplementeerd in Java.
- **Encapsulatie**:
    - Beperk directe toegang tot attributen om de integriteit van objecten te waarborgen.
- **Semantische Integriteit**:
    - Behoud de betekenis en intentie van het ontwerp door nauwkeurige implementatie van associaties en methoden.

## Conclusie

Het **Design Class Diagram (DCD)** speelt een cruciale rol in het softwareontwerpproces door een gedetailleerd en gestructureerd overzicht te bieden van de klassen en hun onderlinge relaties binnen het systeem. Door een duidelijk onderscheid te maken tussen het analiseniveau en het ontwerpniveau, en door zorgvuldig associaties te definiëren met aandacht voor rollen, multipliciteit en navigabiliteit, zorgt het DCD voor een solide basis voor de implementatiefase. De overgang van DCD naar Java-code vereist nauwkeurigheid en consistentie om de semantische integriteit van het ontwerp te behouden, wat uiteindelijk leidt tot een robuust en onderhoudbaar softwaresysteem.

In verdere secties zullen we dieper ingaan op specifieke ontwerpprincipes en -patronen, evenals op het proces van het verfijnen van het DCD door iteratieve stappen, waarbij verantwoordelijkheden systematisch worden toegewezen aan de juiste klassen.
Uitstekend, laten we het gedeelte over het **opbouwen van een ontwerpklassendiagram (DCD)** theoretischer en beknopter formuleren.

# Het Ontwerp: Klassendiagram Opbouwen

## Inleiding

Een **Design Class Diagram (DCD)** is een fundamenteel instrument in het objectgeoriënteerde ontwerpproces. Het biedt een gestructureerde weergave van de klassen binnen een systeem, inclusief hun attributen, methoden en onderlinge relaties. Het DCD vormt de basis voor de implementatiefase, waarbij het analysemodel wordt vertaald naar werkende software.

## Verschil tussen Analyse- en Ontwerpniveau

Het onderscheid tussen **analyseniveau** en **ontwerpniveau** ligt in de detaillering:

- **Analyzeniveau**: Focus op de conceptuele structuur zonder specifieke technische details.
- **Ontwerpniveau**: Verfijnt het model met concrete datatypes, methodesignaturen en gedetailleerde associaties, klaar voor implementatie.

## UML-Diagrammen: Structuur versus Gedrag

**Unified Modeling Language (UML)** categoriseert diagrammen in:

1. **Structuurdiagrammen**: Modelleren de statische aspecten, zoals klassen en hun relaties.
2. **Gedragsdiagrammen**: Beschrijven de dynamische interacties en processen binnen het systeem.

## Kenmerken van een Design Class Diagram

- **Klassen en Attributen**: Definiëren de entiteiten en hun eigenschappen binnen het systeem.
- **Methoden**: Beschrijven het gedrag en de functionaliteit van de klassen.
- **Associaties**: Geven de relaties tussen klassen weer, inclusief multipliciteit en navigabiliteit.
- **Encapsulatie**: Waarborgt dat attributen privé zijn en via methoden toegankelijk, bevorderend voor gegevensintegriteit.

## Associaties tussen Klassen

Associaties specificeren de relaties tussen klassen en omvatten:

1. **Rollen**: Functies van de klassen binnen de relatie.
2. **Multipliciteit**: Aantal instanties dat aan de relatie deelneemt (bijv. 1, 0.._, 1.._).
3. **Naamgeving**: Duidelijke benaming van de relatie vanuit beide klassen.
4. **Visibiliteit**: Toegankelijkheid van de associatie (meestal `private`).
5. **Navigabiliteit**: Richting waarin de associatie kan worden gevolgd (enkelzijdig of dubbelzijdig).

## Van DCD naar Java-code

### Equivalente Klassen

Elke klasse in het DCD correspondeert met een Java-klasse:

- **Naamgeving**: Consistent tussen DCD en Java.
- **Attributen**: Vertalen naar private velden met overeenkomstige datatypes.
- **Methodesignaturen**: Nauwkeurige implementatie van methoden inclusief parameters en returntypes.
- **Constructors**: Initialiseren van objecten volgens het ontwerp.

### Attributen en Associaties in Java

- **Attributen**: Privé-velden in Java, toegankelijk via getters en setters.
- **Associaties**: Gemodelleerd als referentieattributen of verzamelingen (bijv. `List<>`), afhankelijk van de multipliciteit.
- **Encapsulatie**: Handhaaf toegang tot attributen via publieke methoden om gegevensintegriteit te waarborgen.

### Implementatieoverwegingen

- **Consistentie**: Zorg voor een nauwkeurige vertaling van het DCD naar Java-code.
- **Encapsulatie**: Beperk directe toegang tot attributen.
- **Semantische Integriteit**: Behoud de betekenis van relaties en verantwoordelijkheden door correcte implementatie van associaties en methoden.

## Conclusie

Het **Design Class Diagram (DCD)** speelt een cruciale rol in het objectgeoriënteerde ontwerpproces door een gedetailleerde en gestructureerde weergave van klassen en hun relaties te bieden. Door het verschil tussen analyse- en ontwerpniveau te erkennen en UML-structuurdiagrammen correct te interpreteren, vormt het DCD een solide basis voor de implementatiefase. De nauwkeurige vertaling van het DCD naar Java-code, met aandacht voor encapsulatie en consistentie, resulteert in een robuust en onderhoudbaar softwaresysteem.

In de volgende secties zullen we dieper ingaan op specifieke ontwerpprincipes en -patronen, evenals op het proces van het verfijnen van het DCD met behulp van GRASP-patronen zoals **Controller**, **Creator** en **Expert**. Daarnaast behandelen we de methoden voor het definiëren en opsplitsen van systeemoperaties in deelverantwoordelijkheden binnen het DCD, wat bijdraagt aan een effectief en schaalbaar ontwerp.
Uitstekend, laten we het gedeelte over het **ontwikkelen van een Design Class Diagram (DCD)** met behulp van GRASP-principes in de context van een dobbelspel theoretischer en beknopter samenvatten.

# DCD Ontwikkelen met GRASP: Dobbelspel – Iteratie 1 “Speel Spel”

## Inleiding

Het **Design Class Diagram (DCD)** is een kerncomponent in het objectgeoriënteerde ontwerpproces. Het DCD visualiseert de structuur van het systeem door klassen, hun attributen, methoden en onderlinge relaties te definiëren. **GRASP (General Responsibility Assignment Software Patterns)** biedt richtlijnen voor het toewijzen van verantwoordelijkheden aan deze klassen, wat bijdraagt aan een robuust en onderhoudbaar ontwerp.

## Context

Binnen de context van een dobbelspel modelleren we interacties tussen verschillende objecten. De analysefase heeft basisartefacten geleverd, waaronder het domeinmodel, systeemsequentiediagrammen (SSD) en operation contracts (OC’s), die dienen als fundament voor het ontwerp.

## Resultaten van de Analysefase

- **Systeemsequentiediagram (SSD):** Visualiseert de interacties tussen actoren en het systeem gedurende een use case.
- **Domeinmodel:** Identificeert kernconcepten en hun relaties binnen het toepassingsgebied.
- **Operation Contracts (OC’s):** Definiëren de voorwaarden en uitkomsten van systeemoperaties.

## Ontwerpfase

Het doel is het opstellen van een **Design Class Diagram (DCD)** dat de structurele en functionele aspecten van het systeem nauwkeurig weergeeft. Dit diagram dient als blauwdruk voor de implementatie, waarbij het ontwerp aansluit op de bevindingen uit de analysefase.

### Responsibility Driven Design (RDD)

**RDD** richt zich op het toewijzen van verantwoordelijkheden aan objecten, waardoor een duidelijke en cohesieve architectuur ontstaat. Verantwoordelijkheden worden onderverdeeld in:

1. **KNOWING-verantwoordelijkheden:**
    
    - Kennis en teruggeven van informatie.
    - Berekenen of afleiden van data op basis van interne toestand.
2. **DOING-verantwoordelijkheden:**
    
    - Uitvoeren van acties.
    - Initiëren en coördineren van activiteiten binnen andere objecten.

### GRASP Patronen

**GRASP** biedt richtlijnen voor effectieve verantwoordelijkheidstoewijzing:

1. **Controller:**
    
    - Coördineert systeemgebeurtenissen en acties.
    - Dient als centraal aanspreekpunt voor systeemoperaties.
2. **Expert:**
    
    - Beheert en kent relevante informatie.
    - Verantwoordelijk voor het uitvoeren van specifieke taken op basis van expertise.
3. **Creator:**
    
    - Verantwoordelijk voor het aanmaken van nieuwe objecten.
    - Toegewezen aan klassen die intensief gebruikmaken van of aggregaties beheren van het te creëren object.

## Stappenplan voor Systeemoperaties

Voor elke systeemoperatie binnen de use case "Speel spel" volgen we een gestructureerd stappenplan:

### Stap 1: Identificeren van DOING en KNOWING Verantwoordelijkheden

- **DOING-verantwoordelijkheid:**
    - Aanwezigheid van een Operation Contract (OC) of functionaliteit die domeinobjecten manipuleert.
- **KNOWING-verantwoordelijkheid:**
    - Aanwezigheid van een terugkeerpijl in het SSD, wat indicatie geeft van informatieverstrekking.

### Stap 2: Definiëren van Methodesignaturen

- **DOING-methoden:**
    
    - **Naam:** Reflecteert de uitgevoerde actie.
    - **Parameters:** Afhankelijk van de vereiste input.
    - **Returntype:** `void` bij DOING-verantwoordelijkheden.
- **KNOWING-methoden:**
    
    - **Naam:** Beschrijft de verstrekte informatie.
    - **Parameters:** Meestal geen, tenzij aanvullende data nodig is.
    - **Returntype:** Specifiek type data of een Data Transfer Object (DTO).

### Stap 3: Toewijzen van Verantwoordelijkheden aan Klassen

- **Controller Pattern:**
    - De `DomeinController` ontvangt en coördineert systeemoperaties.
- **Creator Pattern:**
    - De `DomeinController` of een specifieke repository is verantwoordelijk voor het aanmaken van nieuwe domeinobjecten, zoals een `Spel`-object.
- **Expert Pattern:**
    - Domeinobjecten zoals `Spel` beheren interne processen en relaties, bijvoorbeeld het aanmaken en beheren van `Dobbelsteen`-objecten.

## Implementatie Overwegingen

- **Encapsulatie:** Attributen zijn privé en toegankelijk via publieke methoden om de integriteit van objecten te waarborgen.
- **Consistentie:** Zorg voor een nauwkeurige vertaling van het DCD naar Java-klassen, met consistente naamgeving en typegebruik.
- **Semantische Integriteit:** Behoud de betekenis en intentie van relaties en verantwoordelijkheden door correcte implementatie van associaties en methoden.

## Conclusie van Iteratie 1

Tijdens de eerste iteratie hebben we de systeemoperaties `startNieuwSpel()` en `rolDobbelstenen()` geanalyseerd en toegewezen aan de juiste klassen binnen het DCD door het toepassen van GRASP-patronen. De `DomeinController` fungeert als coördinator, terwijl het `Spel`-object verantwoordelijk is voor het beheren van `Dobbelsteen`-objecten. Deze toewijzing vormt een solide basis voor de verdere implementatiefase, waarbij het ontwerp klaar is om vertaald te worden naar Java-code.
# Van DCD naar Java

Uitstekend, laten we verder gaan met het theoretisch uitleggen van het proces van het vertalen van een Design Class Diagram (DCD) naar Java-softwareklassen. We zullen ons richten op de kernconcepten en methodologieën, waarbij we concrete voorbeelden vermijden om de uitleg zo algemeen en toepasbaar mogelijk te maken.

## DCD naar Java-softwareklassen Vertalen

### De Basis: Klasse, Attribuut en Methode Definiëren

Bij het vertalen van een DCD naar Java-code is het essentieel om de fundamentele bouwstenen van objectgeoriënteerd programmeren (OOP) correct te implementeren. Deze bouwstenen zijn klassen, attributen en methoden.

#### Klassen

Een **klasse** in Java vertegenwoordigt een blauwdruk voor objecten binnen het systeem. Elke klasse bevat:

- **Attributen**: Eigenschappen die de staat van een object beschrijven.
- **Methoden**: Gedragsfuncties die de functionaliteit van de klasse definiëren.

**Definitie van een Klasse:**

```java
package domein;

public class KlasseNaam {
    // Attributen
    private Datatype attribuutNaam1;
    private Datatype attribuutNaam2;

    // Constructor
    public KlasseNaam() {
        // Initialisatie van attributen
    }

    // Methoden
    public void methodeNaam() {
        // Implementatie van de methode
    }

    // Getters en Setters
    public Datatype getAttribuutNaam1() {
        return attribuutNaam1;
    }

    private void setAttribuutNaam1(Datatype attribuutNaam1) {
        this.attribuutNaam1 = attribuutNaam1;
    }
}
```

**Belangrijke Aspecten:**

1. **Package Declaratie**: Klassen worden georganiseerd binnen packages voor betere modulariteit en organisatie. In dit geval wordt de klasse geplaatst in de package `domein`.
2. **Toegankelijkheidsmodificatoren**: Attributen worden doorgaans `private` gemaakt om **encapsulatie** te bevorderen, wat betekent dat de interne staat van het object niet direct toegankelijk is vanuit andere klassen.
3. **Constructors**: Speciale methoden die worden aangeroepen bij het aanmaken van een nieuw object. Ze initialiseren de attributen van de klasse.
4. **Methoden**: Functies die gedragingen definiëren die objecten van de klasse kunnen uitvoeren.
5. **Getters en Setters**: Publieke methoden die gecontroleerde toegang bieden tot privé-attributen.

### Associaties, Delegeren, Constructors en Verzamelingen

Naast de basiscomponenten van klassen, zijn er aanvullende concepten die essentieel zijn voor een correct ontwerp en implementatie.

#### Associaties

**Associaties** in een DCD geven de relaties aan tussen verschillende klassen. In Java worden deze associaties vaak gemodelleerd als attributen binnen de betrokken klassen.

- **Eendelig**: Een klasse heeft een referentie naar een ander enkelvoudig object.
    
    ```java
    public class KlasseA {
        private KlasseB klasseB;
    }
    ```
    
- **Veelvoudig**: Een klasse heeft een verzameling van objecten van een andere klasse, vaak geïmplementeerd met behulp van collecties zoals `List`.
    
    ```java
    import java.util.List;
    import java.util.ArrayList;
    
    public class KlasseA {
        private List<KlasseB> klasseBList;
    
        public KlasseA() {
            klasseBList = new ArrayList<>();
        }
    }
    ```
    

**Belangrijke Overwegingen:**

1. **Multipliciteit**: Bepaalt het aantal instanties van een klasse dat kan deelnemen aan de relatie. Dit beïnvloedt het datatype van het attribuut (enkelvoudig vs. verzameling).
2. **Visibiliteit**: Associaties worden meestal als `private` gemodelleerd om encapsulatie te waarborgen.
3. **Navigeerbaarheid**: Geeft aan welke kant van de associatie toegankelijk is. Dit wordt in Java gerepresenteerd door de aanwezigheid of afwezigheid van attributen in de betrokken klassen.

#### Delegeren

**Delegeren** is het proces waarbij een klasse de verantwoordelijkheid overdraagt voor een bepaalde taak aan een andere klasse. Dit bevordert een lage koppeling en hoge cohesie binnen het systeem.

**Voorbeeld van Delegeren:**

```java
public class KlasseA {
    private KlasseB klasseB;

    public void voerTaakUit() {
        klasseB.verwerk();
    }
}

public class KlasseB {
    public void verwerk() {
        // Implementatie van de taak
    }
}
```

In dit voorbeeld draagt `KlasseA` de verantwoordelijkheid voor het verwerken van een taak over aan `KlasseB` door de methode `verwerk()` aan te roepen.

#### Constructors

**Constructors** zijn speciale methoden die worden gebruikt om nieuwe objecten van een klasse te initialiseren. Ze hebben geen returntype en de naam komt overeen met de naam van de klasse.

**Voorbeeld van een Constructor:**

```java
public class KlasseA {
    private int waarde;

    public KlasseA(int waarde) {
        this.waarde = waarde;
    }
}
```

**Belangrijke Aspecten:**

1. **Initialisatie**: Constructors zorgen ervoor dat objecten in een geldige staat worden aangemaakt door attributen te initialiseren.
2. **Overloading**: Een klasse kan meerdere constructors hebben met verschillende parameters om flexibiliteit te bieden bij objectcreatie.

#### Verzamelingen

In Java worden **verzamelingen** vaak geïmplementeerd met behulp van de `List` interface en de `ArrayList` klasse. Ze worden gebruikt om meerdere objecten van een bepaalde klasse te beheren.

**Voorbeeld van een Verzamelingsattribuut:**

```java
import java.util.List;
import java.util.ArrayList;

public class KlasseA {
    private List<KlasseB> klasseBList;

    public KlasseA() {
        klasseBList = new ArrayList<>();
    }

    public void voegKlasseBToe(KlasseB klasseB) {
        klasseBList.add(klasseB);
    }
}
```

**Belangrijke Overwegingen:**

1. **Initialisatie**: Het is essentieel om de verzameling te initialiseren in de constructor om `NullPointerException` te voorkomen.
2. **Encapsulatie**: Toegang tot de verzameling wordt vaak gecontroleerd via methoden zoals `voegKlasseBToe`.

### Volledig Ontwerp Implementeren

Na het definiëren van de klassen, attributen, methoden en associaties, kan het volledige ontwerp worden geïmplementeerd in Java-code. Dit omvat het zorgen voor correcte encapsulatie, methodesignaturen en de juiste toewijzing van verantwoordelijkheden aan de klassen.

**Implementatie Stappen:**

1. **Definieer Klassen**: Maak Java-klassen aan die overeenkomen met de klassen in het DCD.
2. **Definieer Attributen**: Voeg privé-attributen toe aan de klassen volgens het DCD.
3. **Implementeer Constructors**: Zorg ervoor dat elke klasse een constructor heeft die de attributen correct initialiseert.
4. **Implementeer Methoden**: Voeg methoden toe aan de klassen die overeenkomen met de methodesignaturen in het DCD.
5. **Modelleer Associaties**: Voeg attributen toe aan de klassen om de relaties tussen klassen te vertegenwoordigen, gebruikmakend van enkelvoudige referenties of verzamelingen.
6. **Encapsulatie**: Voeg getters en setters toe waar nodig, waarbij setters vaak `private` zijn om de integriteit van het object te waarborgen.
7. **Delegeren**: Zorg ervoor dat methoden die verantwoordelijkheden overdragen correct communiceren met de relevante objecten.

### Uitvoerbare Applicatie

Naast de domeinklassen is het vaak noodzakelijk om een uitvoerbare klasse te hebben die fungeert als het startpunt van de applicatie. Deze klasse bevat de `main`-methode die de initiële objecten aanmaakt en de systeemoperaties aanroept.

**Voorbeeld van een Uitvoerbare Klasse:**

```java
package cui;

import domein.DomeinController;

public class Applicatie {
    public static void main(String[] args) {
        new Applicatie().start();
    }

    private void start() {
        // Aanmaken van het aanspreekpunt van de domeinlaag
        DomeinController controller = new DomeinController();
        controller.startNieuwSpel();

        // Uitvoeren van systeemoperaties
        while (!controller.isEindeSpel()) {
            controller.rolDobbelstenen();
            System.out.printf("Aantal ogen: %d%n", controller.geefAantalOgenWorp());
        }

        System.out.printf("Score: %d%n", controller.geefScore());
    }
}
```

**Belangrijke Aspecten:**

1. **Aanmaken van Controller**: De uitvoerbare klasse maakt een instantie aan van de `DomeinController`, die fungeert als het centrale aanspreekpunt voor systeemoperaties.
2. **Aanroepen van Methoden**: Via de controller worden systeemoperaties aangeroepen die de businesslogica uitvoeren.
3. **Interactieve Loop**: Een lus kan worden gebruikt om continue interactie met het systeem te simuleren, gebaseerd op voorwaarden die door de businesslogica worden bepaald.
4. **Invoer- en Uitvoeroperaties**: De uitvoerbare klasse kan verantwoordelijk zijn voor het weergeven van informatie aan de gebruiker via console-uitvoer of een andere vorm van presentatie.

### Conclusie

Het vertalen van een Design Class Diagram (DCD) naar Java-softwareklassen vereist een systematische aanpak waarbij de fundamentele OOP-concepten correct worden geïmplementeerd. Door zorgvuldig klassen, attributen, methoden en associaties te definiëren en verantwoordelijkheden toe te wijzen aan de juiste klassen, kan een robuust en onderhoudbaar softwaresysteem worden ontwikkeld. Encapsulatie, delegatie en het gebruik van verzamelingen zijn cruciale aspecten die bijdragen aan de structuur en functionaliteit van de applicatie.

In de volgende secties zullen we dieper ingaan op geavanceerdere ontwerpprincipes en -patronen, evenals op de implementatie van systeemoperaties en het omzetten van het volledige DCD naar een werkende Java-codebasis.
# DCD: ontwerp aanpassen met _private_ methodes

- Tijdens het implementeren van het ontwerp hebben we verschillende **private** methodes toegevoegd om de code overzichtelijker en herbruikbaarder te maken.
- Methodes toevoegen in de code om de code beter te maken is toegestaan, maar zet deze methodes dan wel `private`.
- Het is **wel belangrijk** om het DCD daarna te **updaten**. Door de private methodes ook toe te voegen aan het DCD, zorgen we ervoor dat het ontwerp en de implementatie op één lijn blijven.


![](20250106102755.png)
Uitstekend, laten we het gedeelte over **Iteratie 2 – Registreer** theoretischer en beknopter samenvatten. We focussen op de kernprincipes van het ontwikkelen van een Design Class Diagram (DCD) met behulp van GRASP-patronen binnen een iteratief ontwikkelingsproces.

# Iteratie 2 – Registreer: Ontwikkeling van het Design Class Diagram

## Inleiding

In een **iteratief ontwikkelingsproces** wordt het softwaresysteem geleidelijk verfijnd en uitgebreid door herhaaldelijk door de fasen van analyse, ontwerp, implementatie en testen te gaan. Elke iteratie richt zich op specifieke use cases, waarbij de focus ligt op het systematisch toewijzen van verantwoordelijkheden aan klassen met behulp van **GRASP (General Responsibility Assignment Software Patterns)**.

## Analysefase Resultaten

Aan het einde van de analysefase zijn de volgende artefacten opgesteld:

- **Use Case Diagrammen**: Beschrijven de interacties tussen actoren en het systeem.
- **Domeinmodel**: Identificeert kernconcepten en hun relaties.
- **Systeemsequentiediagrammen (SSD)**: Visualiseren de volgorde van interacties.
- **Operation Contracts (OC’s)**: Specificeren de voorwaarden en resultaten van systeemoperaties.

## Ontwerpfase: Stappenplan

### Stap 1: Identificeren van Verantwoordelijkheden (DOING & KNOWING)

- **DOING-verantwoordelijkheden**: Betrekken acties die domeinobjecten manipuleren of creëren. Dit wordt doorgaans geïdentificeerd door de aanwezigheid van een Operation Contract (OC) of door functionaliteiten die domeinlogica vereisen.
- **KNOWING-verantwoordelijkheden**: Betrekken het kennen en teruggeven van informatie. Dit wordt geïdentificeerd door terugkeerpijlen in de SSD, die aangeven dat informatie aan de gebruikersinterface wordt verstrekt.

### Stap 2: Definiëren van Methodesignaturen

- **DOING-methoden**:
    - **Naam**: Reflecteert de uitgevoerde actie.
    - **Parameters**: Afhankelijk van de benodigde input.
    - **Returntype**: `void`, aangezien de methode een actie uitvoert zonder direct resultaat.
- **KNOWING-methoden**:
    - **Naam**: Beschrijft de verstrekte informatie.
    - **Parameters**: Meestal geen, tenzij aanvullende data vereist is.
    - **Returntype**: Specifiek datatype of een Data Transfer Object (DTO) voor gestructureerde gegevensoverdracht.

### Stap 3: Toewijzen van Verantwoordelijkheden aan Klassen

- **Controller Pattern**:
    
    - **Doel**: Centraliseren van de coördinatie van systeemoperaties.
    - **Toewijzing**: Een centrale controllerklasse ontvangt en coördineert systeemoperaties.
- **Creator Pattern**:
    
    - **Doel**: Bepalen welke klasse verantwoordelijk is voor het creëren van nieuwe objecten.
    - **Toewijzing**: De klasse die intensief gebruikmaakt van of een verzameling beheert van het te creëren object.
- **Expert Pattern**:
    
    - **Doel**: Toewijzen van verantwoordelijkheden aan de klasse die de meeste relevante informatie bezit.
    - **Toewijzing**: Klassen die de nodige gegevens en logica bevatten om specifieke taken uit te voeren.

## Implementatie Overwegingen

- **Encapsulatie**: Attributen zijn privé en toegankelijk via publieke methoden om gegevensintegriteit te waarborgen.
- **Data Transfer Objects (DTOs)**: Worden gebruikt om gestructureerde en veilige gegevensoverdracht tussen lagen te faciliteren, zonder directe blootstelling van domeinobjecten.
- **Consistentie en Semantische Integriteit**: Zorgvuldig vertalen van het DCD naar implementatie, waarbij de betekenis van relaties en verantwoordelijkheden behouden blijft.

## Conclusie

Door het toepassen van GRASP-principes binnen een iteratief ontwikkelingsproces, worden verantwoordelijkheden systematisch toegewezen aan de juiste klassen. Dit resulteert in een **robust en onderhoudbaar Design Class Diagram (DCD)** dat als solide basis dient voor verdere implementatie en uitbreiding van het systeem. De iteratieve aanpak verzekert dat elke nieuwe functionaliteit zorgvuldig geïntegreerd wordt, waarbij het ontwerp consistent blijft met de geanalyseerde vereisten.

In volgende iteraties zullen deze principes verder worden toegepast op aanvullende use cases, waardoor het systeem geleidelijk aan vollediger en verfijnder wordt.
# Samenvatting
    
## Stap 1: DOING/KNOWING
    
>  - _Stap 1: Vertrek van het SSD en bepaal voor elke systeemoperatie (ook uit loop of alternatief verloop) de doing- en/of knowing-verantwoordelijkheden._

   - **DOING** = object(en) aanmaken/bijhouden/verwijderen of waarde(n) aanpassen.
        - _Algemene regel_:
            1. Als er een OC is, dan is er DOING-verantwoordelijkheid.
            2. Als de systeemoperatie functionaliteit bevat waarbij een domeinobject moet bijgehouden worden, is er DOING-verantwoordelijkheid.


   - **KNOWING** = waarde(n) teruggeven.
        - _Algemene regel_:
            1. Als de systeemoperatie op het SSD een returnpijl heeft, is er KNOWING-verantwoordelijkheid.
                
            2. Bij loop of alternatief verloop: als er data moet worden teruggegeven uit het domein, is er KNOWING-verantwoordelijkheid.

>
>		    1. Een systeemoperatie kan 0, 1 of **meerdere** verantwoordelijkheden hebben.
>		    2. Eén verantwoordelijkheid kan nooit tegelijk DOING én KNOWING zijn.
>		    3. Als er **geen** DOING of KNOWING-verantwoordelijkheid is,
>			    - zorgt de systeemoperatie **niet** voor een methode op het DCD. 
>			    - Geen aanpassingen in het domein dus. 
>			    - Die systeemoperatie zorgt alleen voor wijzigingen in de applicatie.
 >   
    
## Stap 2: Bepaal methode
    
>- _Stap 2: Definieer voor elke verantwoordelijkheid uit stap 1 een methode._
        
  - De definitie van een methode bevat:
        
       1. een betekenisvolle **naam**
       2. eventuele **parameters**
       3. een **returntype**
       
| **DOING**      |                                                                                                                                                                                     |
| -------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **naam**       | Moet betekenisvol zijn. Dekt de naam van het SSD de functionaliteit? Zo ja, hergebruik die naam. Anders bedenk je een nieuwe naam die overeenkomt met de benodigde functionaliteit. |
| **parameters** | Optioneel, alleen als nodig voor deze methode. Staan er op het SSD parameters? Bepaal of deze methode ze echt nodig heeft. Bepaal ook het datatype.                                 |
| **returntype** | `void`                                                                                                                                                                              |

| **KNOWING**    |                                                                                                                                                                                                     |
| -------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **naam**       | Moet betekenisvol zijn. Dekt de naam van het SSD de functionaliteit? Zo ja, hergebruik die naam. Anders bedenk je een nieuwe naam die overeenkomt met de benodigde functionaliteit.                 |
| **parameters** | Optioneel, alleen als nodig voor deze methode.                                                                                                                                                      |
| **returntype** | Bepaal het meest passende datatype voor de terug te geven waarde. _Opletten bij meerdere waardes_: - Allemaal hetzelfde datatype? _Array of List_ - Verschillende datatypes? _Groeperen in een DTO_ |

    
> **Methodes in de DomeinController** die gegevens retourneren naar de UI (publieke methodes) hebben als returntype:
   > 
   > - een primitief type
   > - een voorgedefinieerde Java-klasse (bv. `String`, `LocalDate`)
   > - een **DTO**
   > - of een verzameling (_Array_, _List_, …) van 1 van deze opties. 
   > 
 > De attributen van een DTO mogen ook alleen 1 van de bovenstaande opties als type bevatten.
    
## Stap 3: Opsplitsen in deelverantwoordelijkheden
    
>- _Stap 3: Splits de verantwoordelijkheid op in kleine deelverantwoordelijkheden en plaats ze in een gepaste klasse op het DCD._
    
### Stap 3A: Controller pattern toepassen
    
1. Voeg indien nodig de klasse `DomeinController` toe aan het DCD.
2. Voeg de methode uit stap 2 toe aan de `DomeinController`.
    
### Stap 3B: Deelverantwoordelijkheden toekennen aan de juiste klassen m.b.v. Creator en/of Expert**
    
#### Creator pattern
        
- _Moet er een instantie van een klasse aangemaakt worden?_

	1. **Is de klasse al op het DCD?**
            - Zo nee: neem de klasse over van het domeinmodel en vul bij elk attribuut het datatype in. Neem eventuele associaties over zonder extra info (nog geen associatienaam, rolnamen, multipliciteit).
    2. **Heeft de klasse een constructor met de juiste parameters?**
            - Zo nee: voeg de constructor toe, met de nodige parameters (incl. datatypes) om de instantie correct te kunnen aanmaken.
    3. **Bepaal welke klasse** de constructor zal oproepen en in welke methode dit gebeurt.
            - Bestaat die methode nog niet? Voeg deze toe (eventueel met parameters).
    4. **Bepaal wie** het nieuwe object zal bijhouden.
            - Was er een associatie op het domeinmodel die je eerder overnam? Werk die verder uit (navigeerbaarheid, visibiliteit, naam, multipliciteit).
            - Heb je geen associatie overgenomen in stap 1?  
                  a. Bepaal wie de instantie bijhoudt.  
              b. Voeg een associatie toe tussen deze klassen.  
              c. Werk deze associatie volledig uit: navigeerbaarheid, visibiliteit, naam, multipliciteit.
#### Expert pattern
        
>- _Wie is verantwoordelijk om een bepaalde actie uit te voeren?_
   >         
   >- **Ken** de verantwoordelijkheid toe aan de Information Expert, de klasse die alle benodigde info heeft om de verantwoordelijkheid te realiseren.
            
   1. Kijk eerst op het DCD of daar klassen zijn die in aanmerking komen.
        - Zo ja: voeg de methode aan deze klasse toe.
  2. In tweede instantie kan het domeinmodel inspiratie geven voor een geschikte klasse.
        - Zo ja: Voeg de klasse toe aan het DCD, denk na over associaties voor je de methode toevoegt.
  3. Mogelijks maak je een nieuwe klasse met een duidelijke rol en verantwoordelijkheid (denk weer aan associaties).

		
- **Eens je de klasse hebt gevonden die EXPERT is** over alle info om de verantwoordelijkheid te realiseren, 
	- controleer je of de `DomeinController` expert is over **die** klasse. Alleen dan kan de DomeinController de net toegevoegde methode aanroepen.    
 - Is de DomeinController **geen** expert? 
	 - Ga dan op zoek naar de “ketting” tussen de DomeinController en de klasse en voeg bij elke stap in de ketting een methode toe.